// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'payment_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PaymentFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentFailureCopyWith<$Res> {
  factory $PaymentFailureCopyWith(
          PaymentFailure value, $Res Function(PaymentFailure) then) =
      _$PaymentFailureCopyWithImpl<$Res, PaymentFailure>;
}

/// @nodoc
class _$PaymentFailureCopyWithImpl<$Res, $Val extends PaymentFailure>
    implements $PaymentFailureCopyWith<$Res> {
  _$PaymentFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PaymentUnexpectedFailureImplCopyWith<$Res> {
  factory _$$PaymentUnexpectedFailureImplCopyWith(
          _$PaymentUnexpectedFailureImpl value,
          $Res Function(_$PaymentUnexpectedFailureImpl) then) =
      __$$PaymentUnexpectedFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$PaymentUnexpectedFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$PaymentUnexpectedFailureImpl>
    implements _$$PaymentUnexpectedFailureImplCopyWith<$Res> {
  __$$PaymentUnexpectedFailureImplCopyWithImpl(
      _$PaymentUnexpectedFailureImpl _value,
      $Res Function(_$PaymentUnexpectedFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$PaymentUnexpectedFailureImpl(
      freezed == error ? _value.error : error,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$PaymentUnexpectedFailureImpl extends PaymentUnexpectedFailure
    with UnexpectedFailure {
  const _$PaymentUnexpectedFailureImpl([this.error, this.stackTrace])
      : super._();

  @override
  final Object? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'PaymentFailure.unexpected(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentUnexpectedFailureImpl &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentUnexpectedFailureImplCopyWith<_$PaymentUnexpectedFailureImpl>
      get copyWith => __$$PaymentUnexpectedFailureImplCopyWithImpl<
          _$PaymentUnexpectedFailureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return unexpected(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return unexpected?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class PaymentUnexpectedFailure extends PaymentFailure
    implements UnexpectedFailure {
  const factory PaymentUnexpectedFailure(
      [final Object? error,
      final StackTrace? stackTrace]) = _$PaymentUnexpectedFailureImpl;
  const PaymentUnexpectedFailure._() : super._();

  Object? get error;
  StackTrace? get stackTrace;
  @JsonKey(ignore: true)
  _$$PaymentUnexpectedFailureImplCopyWith<_$PaymentUnexpectedFailureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentInvalidAmountFailureImplCopyWith<$Res> {
  factory _$$PaymentInvalidAmountFailureImplCopyWith(
          _$PaymentInvalidAmountFailureImpl value,
          $Res Function(_$PaymentInvalidAmountFailureImpl) then) =
      __$$PaymentInvalidAmountFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentInvalidAmountFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res,
        _$PaymentInvalidAmountFailureImpl>
    implements _$$PaymentInvalidAmountFailureImplCopyWith<$Res> {
  __$$PaymentInvalidAmountFailureImplCopyWithImpl(
      _$PaymentInvalidAmountFailureImpl _value,
      $Res Function(_$PaymentInvalidAmountFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentInvalidAmountFailureImpl extends PaymentInvalidAmountFailure {
  const _$PaymentInvalidAmountFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.invalidAmount()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentInvalidAmountFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return invalidAmount();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return invalidAmount?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (invalidAmount != null) {
      return invalidAmount();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return invalidAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return invalidAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (invalidAmount != null) {
      return invalidAmount(this);
    }
    return orElse();
  }
}

abstract class PaymentInvalidAmountFailure extends PaymentFailure {
  const factory PaymentInvalidAmountFailure() =
      _$PaymentInvalidAmountFailureImpl;
  const PaymentInvalidAmountFailure._() : super._();
}

/// @nodoc
abstract class _$$PaymentCancelledFailureImplCopyWith<$Res> {
  factory _$$PaymentCancelledFailureImplCopyWith(
          _$PaymentCancelledFailureImpl value,
          $Res Function(_$PaymentCancelledFailureImpl) then) =
      __$$PaymentCancelledFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentCancelledFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$PaymentCancelledFailureImpl>
    implements _$$PaymentCancelledFailureImplCopyWith<$Res> {
  __$$PaymentCancelledFailureImplCopyWithImpl(
      _$PaymentCancelledFailureImpl _value,
      $Res Function(_$PaymentCancelledFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentCancelledFailureImpl extends PaymentCancelledFailure {
  const _$PaymentCancelledFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.paymentCancelled()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentCancelledFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return paymentCancelled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return paymentCancelled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (paymentCancelled != null) {
      return paymentCancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return paymentCancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return paymentCancelled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (paymentCancelled != null) {
      return paymentCancelled(this);
    }
    return orElse();
  }
}

abstract class PaymentCancelledFailure extends PaymentFailure {
  const factory PaymentCancelledFailure() = _$PaymentCancelledFailureImpl;
  const PaymentCancelledFailure._() : super._();
}

/// @nodoc
abstract class _$$PaymentFailedFailureImplCopyWith<$Res> {
  factory _$$PaymentFailedFailureImplCopyWith(_$PaymentFailedFailureImpl value,
          $Res Function(_$PaymentFailedFailureImpl) then) =
      __$$PaymentFailedFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? message});
}

/// @nodoc
class __$$PaymentFailedFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$PaymentFailedFailureImpl>
    implements _$$PaymentFailedFailureImplCopyWith<$Res> {
  __$$PaymentFailedFailureImplCopyWithImpl(_$PaymentFailedFailureImpl _value,
      $Res Function(_$PaymentFailedFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$PaymentFailedFailureImpl(
      freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$PaymentFailedFailureImpl extends PaymentFailedFailure {
  const _$PaymentFailedFailureImpl([this.message]) : super._();

  @override
  final String? message;

  @override
  String toString() {
    return 'PaymentFailure.paymentFailed(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentFailedFailureImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentFailedFailureImplCopyWith<_$PaymentFailedFailureImpl>
      get copyWith =>
          __$$PaymentFailedFailureImplCopyWithImpl<_$PaymentFailedFailureImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return paymentFailed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return paymentFailed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return paymentFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return paymentFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed(this);
    }
    return orElse();
  }
}

abstract class PaymentFailedFailure extends PaymentFailure {
  const factory PaymentFailedFailure([final String? message]) =
      _$PaymentFailedFailureImpl;
  const PaymentFailedFailure._() : super._();

  String? get message;
  @JsonKey(ignore: true)
  _$$PaymentFailedFailureImplCopyWith<_$PaymentFailedFailureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentTimeoutFailureImplCopyWith<$Res> {
  factory _$$PaymentTimeoutFailureImplCopyWith(
          _$PaymentTimeoutFailureImpl value,
          $Res Function(_$PaymentTimeoutFailureImpl) then) =
      __$$PaymentTimeoutFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentTimeoutFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$PaymentTimeoutFailureImpl>
    implements _$$PaymentTimeoutFailureImplCopyWith<$Res> {
  __$$PaymentTimeoutFailureImplCopyWithImpl(_$PaymentTimeoutFailureImpl _value,
      $Res Function(_$PaymentTimeoutFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentTimeoutFailureImpl extends PaymentTimeoutFailure {
  const _$PaymentTimeoutFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.paymentTimeout()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentTimeoutFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return paymentTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return paymentTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (paymentTimeout != null) {
      return paymentTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return paymentTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return paymentTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (paymentTimeout != null) {
      return paymentTimeout(this);
    }
    return orElse();
  }
}

abstract class PaymentTimeoutFailure extends PaymentFailure {
  const factory PaymentTimeoutFailure() = _$PaymentTimeoutFailureImpl;
  const PaymentTimeoutFailure._() : super._();
}

/// @nodoc
abstract class _$$PaymentProviderUnavailableFailureImplCopyWith<$Res> {
  factory _$$PaymentProviderUnavailableFailureImplCopyWith(
          _$PaymentProviderUnavailableFailureImpl value,
          $Res Function(_$PaymentProviderUnavailableFailureImpl) then) =
      __$$PaymentProviderUnavailableFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentProviderUnavailableFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res,
        _$PaymentProviderUnavailableFailureImpl>
    implements _$$PaymentProviderUnavailableFailureImplCopyWith<$Res> {
  __$$PaymentProviderUnavailableFailureImplCopyWithImpl(
      _$PaymentProviderUnavailableFailureImpl _value,
      $Res Function(_$PaymentProviderUnavailableFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentProviderUnavailableFailureImpl
    extends PaymentProviderUnavailableFailure {
  const _$PaymentProviderUnavailableFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.providerUnavailable()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentProviderUnavailableFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return providerUnavailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return providerUnavailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (providerUnavailable != null) {
      return providerUnavailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return providerUnavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return providerUnavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (providerUnavailable != null) {
      return providerUnavailable(this);
    }
    return orElse();
  }
}

abstract class PaymentProviderUnavailableFailure extends PaymentFailure {
  const factory PaymentProviderUnavailableFailure() =
      _$PaymentProviderUnavailableFailureImpl;
  const PaymentProviderUnavailableFailure._() : super._();
}

/// @nodoc
abstract class _$$PaymentNetworkFailureImplCopyWith<$Res> {
  factory _$$PaymentNetworkFailureImplCopyWith(
          _$PaymentNetworkFailureImpl value,
          $Res Function(_$PaymentNetworkFailureImpl) then) =
      __$$PaymentNetworkFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentNetworkFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$PaymentNetworkFailureImpl>
    implements _$$PaymentNetworkFailureImplCopyWith<$Res> {
  __$$PaymentNetworkFailureImplCopyWithImpl(_$PaymentNetworkFailureImpl _value,
      $Res Function(_$PaymentNetworkFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentNetworkFailureImpl extends PaymentNetworkFailure {
  const _$PaymentNetworkFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.networkError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentNetworkFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return networkError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return networkError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return networkError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return networkError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError(this);
    }
    return orElse();
  }
}

abstract class PaymentNetworkFailure extends PaymentFailure {
  const factory PaymentNetworkFailure() = _$PaymentNetworkFailureImpl;
  const PaymentNetworkFailure._() : super._();
}

/// @nodoc
abstract class _$$PaymentInvalidConfigFailureImplCopyWith<$Res> {
  factory _$$PaymentInvalidConfigFailureImplCopyWith(
          _$PaymentInvalidConfigFailureImpl value,
          $Res Function(_$PaymentInvalidConfigFailureImpl) then) =
      __$$PaymentInvalidConfigFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentInvalidConfigFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res,
        _$PaymentInvalidConfigFailureImpl>
    implements _$$PaymentInvalidConfigFailureImplCopyWith<$Res> {
  __$$PaymentInvalidConfigFailureImplCopyWithImpl(
      _$PaymentInvalidConfigFailureImpl _value,
      $Res Function(_$PaymentInvalidConfigFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentInvalidConfigFailureImpl extends PaymentInvalidConfigFailure {
  const _$PaymentInvalidConfigFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.invalidConfig()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentInvalidConfigFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return invalidConfig();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return invalidConfig?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (invalidConfig != null) {
      return invalidConfig();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return invalidConfig(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return invalidConfig?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (invalidConfig != null) {
      return invalidConfig(this);
    }
    return orElse();
  }
}

abstract class PaymentInvalidConfigFailure extends PaymentFailure {
  const factory PaymentInvalidConfigFailure() =
      _$PaymentInvalidConfigFailureImpl;
  const PaymentInvalidConfigFailure._() : super._();
}

/// @nodoc
abstract class _$$SubscriptionNotFoundFailureImplCopyWith<$Res> {
  factory _$$SubscriptionNotFoundFailureImplCopyWith(
          _$SubscriptionNotFoundFailureImpl value,
          $Res Function(_$SubscriptionNotFoundFailureImpl) then) =
      __$$SubscriptionNotFoundFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubscriptionNotFoundFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res,
        _$SubscriptionNotFoundFailureImpl>
    implements _$$SubscriptionNotFoundFailureImplCopyWith<$Res> {
  __$$SubscriptionNotFoundFailureImplCopyWithImpl(
      _$SubscriptionNotFoundFailureImpl _value,
      $Res Function(_$SubscriptionNotFoundFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SubscriptionNotFoundFailureImpl extends SubscriptionNotFoundFailure {
  const _$SubscriptionNotFoundFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.subscriptionNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionNotFoundFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return subscriptionNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return subscriptionNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (subscriptionNotFound != null) {
      return subscriptionNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return subscriptionNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return subscriptionNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (subscriptionNotFound != null) {
      return subscriptionNotFound(this);
    }
    return orElse();
  }
}

abstract class SubscriptionNotFoundFailure extends PaymentFailure {
  const factory SubscriptionNotFoundFailure() =
      _$SubscriptionNotFoundFailureImpl;
  const SubscriptionNotFoundFailure._() : super._();
}

/// @nodoc
abstract class _$$SubscriptionExpiredFailureImplCopyWith<$Res> {
  factory _$$SubscriptionExpiredFailureImplCopyWith(
          _$SubscriptionExpiredFailureImpl value,
          $Res Function(_$SubscriptionExpiredFailureImpl) then) =
      __$$SubscriptionExpiredFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubscriptionExpiredFailureImplCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$SubscriptionExpiredFailureImpl>
    implements _$$SubscriptionExpiredFailureImplCopyWith<$Res> {
  __$$SubscriptionExpiredFailureImplCopyWithImpl(
      _$SubscriptionExpiredFailureImpl _value,
      $Res Function(_$SubscriptionExpiredFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SubscriptionExpiredFailureImpl extends SubscriptionExpiredFailure {
  const _$SubscriptionExpiredFailureImpl() : super._();

  @override
  String toString() {
    return 'PaymentFailure.subscriptionExpired()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionExpiredFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Object? error, StackTrace? stackTrace) unexpected,
    required TResult Function() invalidAmount,
    required TResult Function() paymentCancelled,
    required TResult Function(String? message) paymentFailed,
    required TResult Function() paymentTimeout,
    required TResult Function() providerUnavailable,
    required TResult Function() networkError,
    required TResult Function() invalidConfig,
    required TResult Function() subscriptionNotFound,
    required TResult Function() subscriptionExpired,
  }) {
    return subscriptionExpired();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult? Function()? invalidAmount,
    TResult? Function()? paymentCancelled,
    TResult? Function(String? message)? paymentFailed,
    TResult? Function()? paymentTimeout,
    TResult? Function()? providerUnavailable,
    TResult? Function()? networkError,
    TResult? Function()? invalidConfig,
    TResult? Function()? subscriptionNotFound,
    TResult? Function()? subscriptionExpired,
  }) {
    return subscriptionExpired?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Object? error, StackTrace? stackTrace)? unexpected,
    TResult Function()? invalidAmount,
    TResult Function()? paymentCancelled,
    TResult Function(String? message)? paymentFailed,
    TResult Function()? paymentTimeout,
    TResult Function()? providerUnavailable,
    TResult Function()? networkError,
    TResult Function()? invalidConfig,
    TResult Function()? subscriptionNotFound,
    TResult Function()? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (subscriptionExpired != null) {
      return subscriptionExpired();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentUnexpectedFailure value) unexpected,
    required TResult Function(PaymentInvalidAmountFailure value) invalidAmount,
    required TResult Function(PaymentCancelledFailure value) paymentCancelled,
    required TResult Function(PaymentFailedFailure value) paymentFailed,
    required TResult Function(PaymentTimeoutFailure value) paymentTimeout,
    required TResult Function(PaymentProviderUnavailableFailure value)
        providerUnavailable,
    required TResult Function(PaymentNetworkFailure value) networkError,
    required TResult Function(PaymentInvalidConfigFailure value) invalidConfig,
    required TResult Function(SubscriptionNotFoundFailure value)
        subscriptionNotFound,
    required TResult Function(SubscriptionExpiredFailure value)
        subscriptionExpired,
  }) {
    return subscriptionExpired(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentUnexpectedFailure value)? unexpected,
    TResult? Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult? Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult? Function(PaymentFailedFailure value)? paymentFailed,
    TResult? Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult? Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult? Function(PaymentNetworkFailure value)? networkError,
    TResult? Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult? Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult? Function(SubscriptionExpiredFailure value)? subscriptionExpired,
  }) {
    return subscriptionExpired?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentUnexpectedFailure value)? unexpected,
    TResult Function(PaymentInvalidAmountFailure value)? invalidAmount,
    TResult Function(PaymentCancelledFailure value)? paymentCancelled,
    TResult Function(PaymentFailedFailure value)? paymentFailed,
    TResult Function(PaymentTimeoutFailure value)? paymentTimeout,
    TResult Function(PaymentProviderUnavailableFailure value)?
        providerUnavailable,
    TResult Function(PaymentNetworkFailure value)? networkError,
    TResult Function(PaymentInvalidConfigFailure value)? invalidConfig,
    TResult Function(SubscriptionNotFoundFailure value)? subscriptionNotFound,
    TResult Function(SubscriptionExpiredFailure value)? subscriptionExpired,
    required TResult orElse(),
  }) {
    if (subscriptionExpired != null) {
      return subscriptionExpired(this);
    }
    return orElse();
  }
}

abstract class SubscriptionExpiredFailure extends PaymentFailure {
  const factory SubscriptionExpiredFailure() = _$SubscriptionExpiredFailureImpl;
  const SubscriptionExpiredFailure._() : super._();
}
